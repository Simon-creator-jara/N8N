import type {
  IExecuteFunctions,
  IDataObject,
  INodeExecutionData,
  INodeType,
  INodeTypeDescription,
} from 'n8n-workflow';
import {
  NodeConnectionTypes,
} from 'n8n-workflow';
import { awsApiRequestREST } from './GenericFunctions';

export class BancolombiaAwsSecretsManager implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Bancolombia Aws Secrets Manager',
    name: 'bancolombiaAwsSecretsManager',
    icon: {
      light: 'file:icons/bancolombia-ia.svg',
      dark: 'file:icons/bancolombia-ia.dark.svg',
    },
    group: ['output'],
    version: 1,
    subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
    description: 'Manage AWS Secrets Manager',
    defaults: {
      name: 'bancolombiaAwsSecretsManager',
    },
    usableAsTool: true,
    inputs: [NodeConnectionTypes.Main],
    outputs: [NodeConnectionTypes.Main],
    credentials: [
      {
        name: 'bancolombia_aws',
        required: true,
      },
    ],
    properties: [
      {
        displayName: 'Operation',
        name: 'operation',
        type: 'options',
        noDataExpression: true,
        options: [
          {
            name: 'Get Secret Value',
            value: 'getSecretValue',
            description: 'Retrieve the secret value',
            action: 'Get a secret value',
          },
        ],
        default: 'getSecretValue',
      },
      {
        displayName: 'Secret ID or ARN',
        name: 'secretId',
        type: 'string',
        required: true,
        default: '',
        placeholder: 'my/secret/name or arn:aws:secretsmanager:...',
      },
      {
        displayName: 'Output',
        name: 'outputMode',
        type: 'options',
        options: [
          {
            name: 'JSON/Text',
            value: 'text',
            description:
              'Return the secret as JSON or plain text (SecretString)',
            action: 'Return the secret as JSON or plain text',
          },
          {
            name: 'Binary (SecretBinary)',
            value: 'binary',
            description: 'Return the secret as binary (SecretBinary)',
            action: 'Return the secret as binary',
          },
        ],
        default: 'text',
      },
      {
        displayName: 'Parse JSON SecretString',
        name: 'parseJson',
        type: 'boolean',
        default: true,
        displayOptions: {
          show: { outputMode: ['text'] },
        },
      },
      {
        displayName: 'Binary Property',
        name: 'binaryPropertyName',
        type: 'string',
        default: 'data',
        displayOptions: {
          show: { outputMode: ['binary'] },
        },
      },
    ],
  };

  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
    const items = this.getInputData();
    const returnData: INodeExecutionData[] = [];

    for (let i = 0; i < items.length; i++) {
      const operation = this.getNodeParameter('operation', i) as string;

      if (operation === 'getSecretValue') {
        const secretId = this.getNodeParameter('secretId', i) as string;
        const outputMode = this.getNodeParameter('outputMode', i) as string;

        const headers = {
          'X-Amz-Target': 'secretsmanager.GetSecretValue',
          'Content-Type': 'application/x-amz-json-1.1',
        };

        const body: string = JSON.stringify({
          SecretId: secretId,
        });

        const response = await awsApiRequestREST.call(
          this,
          'secretsmanager',
          'POST',
          '/',
          body,
          {},
          headers,
        );

        console.log('Response:', response);

        if (outputMode === 'binary') {
          const prop = this.getNodeParameter('binaryPropertyName', i) as string;
          // Prefer SecretBinary (base64) else fall back to SecretString (utf8)
          let bin: Buffer | undefined;
          if (response && response.SecretBinary) {
            bin = Buffer.from(response.SecretBinary as string, 'base64');
          } else if (response && response.SecretString) {
            bin = Buffer.from(response.SecretString as string, 'utf8');
          }

          if (!bin) {
            throw new Error(
              'No secret returned: Secrets Manager response has no SecretBinary or SecretString',
            );
          }

          const newItem: INodeExecutionData = {
            json: {
              secretId,
              versionId: response.VersionId,
              versionStages: response.VersionStages,
            },
            binary: {},
          };
          if (items[i].binary) Object.assign(newItem.binary!, items[i].binary);

          newItem.binary![prop] = await this.helpers.prepareBinaryData(
            bin,
            'secret.bin',
            'application/octet-stream',
          );

          returnData.push(
            ...this.helpers.constructExecutionMetaData([newItem], {
              itemData: { item: i },
            }),
          );
        } else {
          const parseJson = this.getNodeParameter('parseJson', i) as boolean;
          let payload: unknown = response.SecretString;

          if (parseJson) {
            try {
              payload = JSON.parse(response.SecretString as string);
            } catch {
              // keep as text if not JSON
            }
          }

          returnData.push(
            ...this.helpers.constructExecutionMetaData(
              this.helpers.returnJsonArray([
                {
                  secretId,
                  versionId: response.VersionId,
                  versionStages: response.VersionStages,
                  secret: payload,
                } as IDataObject,
              ]),
              { itemData: { item: i } },
            ),
          );
        }
      }
    }

    return [returnData];
  }
}
