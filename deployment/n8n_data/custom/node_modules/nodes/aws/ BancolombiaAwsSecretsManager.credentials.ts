import type { Request } from 'aws4';
import { sign } from 'aws4';
import { STSClient, AssumeRoleCommand } from '@aws-sdk/client-sts';
import type {
  ICredentialDataDecryptedObject,
  ICredentialType,
  IDataObject,
  IHttpRequestHelper,
  INodeProperties,
  IHttpRequestOptions,
} from 'n8n-workflow';

type RegionData = {
  name: string;
  displayName: string;
  location: string;
  domain?: string;
};

export const regions: RegionData[] = [
  {
    name: 'us-east-1',
    displayName: 'US East',
    location: 'N. Virginia',
  },
] as const;

export type AWSRegion = (typeof regions)[number]['name'];
export type BancolombiaAwsCredentialsType = {
  region: AWSRegion;
  secretIdOrArn: string;
  temporaryCredentials: boolean;
  awsCredentials: boolean;
  assumeRole: boolean;
  accessKeyId?: string;
  secretAccessKey?: string;
  sessionToken?: string;
  roleToAssume?: string;
  durationSeconds?: number;
};

const globalDomain = 'amazonaws.com';
function getAwsDomain(region: AWSRegion): string {
  return regions.find((r) => r.name === region)?.domain ?? globalDomain;
}

export class BancolombiaAwsSecretsManager implements ICredentialType {
  name = 'bancolombia_aws_secrets_manager';

  displayName = 'Bancolombia AWS Secrets Manager';

  documentationUrl = 'aws';

  icon = {
    light: 'file:icons/bancolombia-ia.svg',
    dark: 'file:icons/bancolombia-ia.dark.svg',
  } as const;

  properties: INodeProperties[] = [
    {
      displayName: 'Region',
      name: 'region',
      type: 'options',
      options: regions.map((r) => ({
        name: `${r.displayName} (${r.location}) - ${r.name}`,
        value: r.name,
      })),
      default: 'us-east-1',
    },
    {
      displayName: 'Secret ID or ARN',
      name: 'secretIdOrArn',
      type: 'string',
      required: true,
      default: '',
      description:
        'The identifier for the secret. You can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.',
    },
    {
      displayName: 'Temporary Security Credentials',
      name: 'temporaryCredentials',
      description: 'Support for temporary credentials from AWS STS',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'AWS Credentials',
      name: 'awsCredentials',
      description: 'Support for AWS Credentials Access Keys',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'Assume Role',
      name: 'assumeRole',
      description: 'Support for Assume other roles from n8n ou role',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'Access Key ID',
      name: 'accessKeyId',
      type: 'string',
      displayOptions: {
        show: {
          awsCredentials: [true],
        },
      },
      default: '',
    },
    {
      displayName: 'Secret Access Key',
      name: 'secretAccessKey',
      type: 'string',
      displayOptions: {
        show: {
          awsCredentials: [true],
        },
      },
      default: '',
      typeOptions: {
        password: true,
      },
    },
    {
      displayName: 'Session Token',
      name: 'sessionToken',
      type: 'string',
      displayOptions: {
        show: {
          temporaryCredentials: [true],
        },
      },
      default: '',
      typeOptions: {
        password: true,
      },
    },
    {
      displayName: 'Role To Assume',
      name: 'roleToAssume',
      type: 'string',
      displayOptions: {
        show: {
          assumeRole: [true],
        },
      },
      default: '',
    },
    {
      displayName: 'Duration Seconds',
      name: 'durationSeconds',
      type: 'number',
      displayOptions: {
        show: {
          assumeRole: [true],
        },
      },
      default: 3600,
    },
  ];

  async preAuthentication(
    this: IHttpRequestHelper,
    credentials: ICredentialDataDecryptedObject,
  ): Promise<IDataObject> {
    const rawCredentials = credentials as BancolombiaAwsCredentialsType;
    let awsCredentials = {};

    // If you require base keys for STS, validate here
    if (rawCredentials.assumeRole) {
      if (!rawCredentials.roleToAssume) {
        throw new Error('roleToAssume is required when assumeRole is enabled.');
      }

      const sts = new STSClient();

      const out = await sts.send(
        new AssumeRoleCommand({
          RoleArn: rawCredentials.roleToAssume.trim(),
          RoleSessionName: `n8n-${Date.now()}`,
          DurationSeconds: rawCredentials.durationSeconds,
        }),
      );

      if (!out.Credentials)
        throw new Error('AssumeRole returned no credentials');

      let accessKeyId = out.Credentials.AccessKeyId!;
      let secretAccessKey = out.Credentials.SecretAccessKey!;
      let sessionToken = out.Credentials.SessionToken!;

      awsCredentials = {
        accessKeyId,
        secretAccessKey,
        sessionToken,
      };
    }

    if (
      rawCredentials.temporaryCredentials &&
      rawCredentials.awsCredentials &&
      rawCredentials.sessionToken &&
      rawCredentials.accessKeyId &&
      rawCredentials.secretAccessKey
    ) {
      awsCredentials = {
        accessKeyId: rawCredentials.accessKeyId?.trim(),
        secretAccessKey: rawCredentials.secretAccessKey?.trim(),
        sessionToken: rawCredentials.sessionToken?.trim(),
      };
    }

    if (rawCredentials.awsCredentials) {
      awsCredentials = {
        accessKeyId: rawCredentials.accessKeyId?.trim(),
        secretAccessKey: rawCredentials.secretAccessKey?.trim(),
        sessionToken: undefined,
      };
    }

    return awsCredentials;
  }

  async authenticate(
    rawCredentials: ICredentialDataDecryptedObject,
    requestOptions: IHttpRequestOptions,
  ): Promise<IHttpRequestOptions> {
    const credentials = rawCredentials as BancolombiaAwsCredentialsType;
    const { accessKeyId, secretAccessKey, sessionToken } =
      rawCredentials as any;

    let endpoint: URL;
    let service = 'secretsmanager';
    let path = '/';
    const method = 'POST';
    const headers = {
      'X-Amz-Target': 'secretsmanager.GetSecretValue',
      'Content-Type': 'application/x-amz-json-1.1',
    };
    let body = JSON.stringify({ SecretId: credentials.secretIdOrArn });

    let region = credentials.region;
    let endpointString: string;
    const domain = getAwsDomain(region);
    endpointString = `https://${service}.${region}.${domain}`;
    endpoint = new URL(endpointString!.replace('{region}', region) + path);
    // ! aws4.sign *must* have the body to sign, but we might have .form instead of .body
    const requestWithForm = requestOptions as unknown as {
      form?: Record<string, string>;
    };
    let bodyContent = body !== '' ? body : undefined;
    let contentTypeHeader: string | undefined = undefined;
    if (requestWithForm.form) {
      const params = new URLSearchParams();
      for (const key in requestWithForm.form) {
        params.append(key, requestWithForm.form[key]);
      }
      bodyContent = params.toString();
      contentTypeHeader = 'application/x-www-form-urlencoded';
    }
    const signOpts = {
      ...requestOptions,
      headers: {
        ...(headers ?? {}),
        ...(contentTypeHeader && { 'content-type': contentTypeHeader }),
      },
      host: endpoint.host,
      method,
      path,
      body: bodyContent,
      region,
    } as unknown as Request;

    const securityHeaders = {
      accessKeyId: accessKeyId,
      secretAccessKey: secretAccessKey,
      sessionToken: sessionToken,
    };
    try {
      sign(signOpts, securityHeaders);
    } catch (err) {
      console.error(err);
    }
    const options: IHttpRequestOptions = {
      ...requestOptions,
      headers: signOpts.headers,
      method,
      url: endpoint.origin + path,
      body: signOpts.body,
      qs: undefined, // override since it's already in the url
    };
    console.log('Signed Request Options:', options);
    return options;
  }
}
