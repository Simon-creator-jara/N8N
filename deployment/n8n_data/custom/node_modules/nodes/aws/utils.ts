import { regions, globalDomain, AWSRegion, AwsCredentialsType } from './types';
import { readFileSync } from 'fs';
import type { Request } from 'aws4';
import { sign } from 'aws4';
import type {
  IDataObject,
  IHttpRequestOptions,
  IRequestOptions,
  IHttpRequestHelper,
} from 'n8n-workflow';
import { isObjectEmpty } from 'n8n-workflow';

function getAwsDomain(region: AWSRegion): string {
  return regions.find((r) => r.name === region)?.domain ?? globalDomain;
}

// Some AWS services are global and don't have a region
// https://docs.aws.amazon.com/general/latest/gr/rande.html#global-endpoints
// Example: iam.amazonaws.com (global), s3.us-east-1.amazonaws.com (regional)
function parseAwsUrl(url: URL): { region: AWSRegion | null; service: string } {
  const hostname = url.hostname;
  // Handle both .amazonaws.com and .amazonaws.com.cn domains
  const [service, region] = hostname
    .replace(/\.amazonaws\.com.*$/, '')
    .split('.');
  return { service, region };
}

export async function getSTSApiRequestCredentials(
  this: IHttpRequestHelper,
): Promise<AwsCredentialsType> {
  const roleToAssumeArn = process.env.AWS_ROLE_ARN || '';
  const tokenFile = process.env.AWS_WEB_IDENTITY_TOKEN_FILE || '';
  const awsRegion = process.env.AWS_REGION || 'us-east-1';

  if (!roleToAssumeArn || !tokenFile) {
    throw new Error(
      'Environment variables AWS_ROLE_ARN and AWS_WEB_IDENTITY_TOKEN_FILE must be set',
    );
  }

  try {
    const webIdentityToken = readFileSync(tokenFile, 'utf8');
    const requestWithForm = {
      form: {
        Action: 'AssumeRoleWithWebIdentity',
        Version: '2011-06-15',
        RoleArn: roleToAssumeArn,
        RoleSessionName: `n8n-custom-api-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        DurationSeconds: '3600', // Optional: session duration
      },
    } as { form: Record<string, string> };
    const params = new URLSearchParams();
    for (const key in requestWithForm.form) {
      params.append(key, requestWithForm.form[key]);
    }
    let bodyContent = params.toString();
    let contentTypeHeader = 'application/x-www-form-urlencoded';
    const options: IHttpRequestOptions = {
      headers: {
        'Content-Type': contentTypeHeader,
      },
      method: 'POST',
      url: 'https://sts.' + awsRegion + '.amazonaws.com/',
      body: bodyContent.toString(),
      qs: undefined,
    };
    const response = await this.helpers.httpRequest(options);
    const credentials = response.AssumeRoleWithWebIdentityResponse.AssumeRoleWithWebIdentityResult
        .Credentials;
    return {
      temporaryCredentials: true,
      region: 'us-east-1',
      customEndpoints: false,
      expiration: 3600,
      accessKeyId: credentials.AccessKeyId,
      secretAccessKey: credentials.SecretAccessKey,
      sessionToken: credentials.SessionToken
    };
  } catch (err) {
    throw new Error(
      'Failed to generate STS request options: ' + (err as Error).message,
    );
  }
}

export async function getAWSApiRequestOptions(
  requestOptions: IHttpRequestOptions,
  rawCredentials: AwsCredentialsType,
): Promise<IHttpRequestOptions> {
  const credentials = rawCredentials;
  let endpoint: URL;
  let service = requestOptions.qs?.service as string;
  let path = (requestOptions.qs?.path as string) ?? '';
  const method = requestOptions.method;
  let body = requestOptions.body;

  let region = credentials.region;
  if (requestOptions.qs?._region) {
    region = requestOptions.qs._region as AWSRegion;
    delete requestOptions.qs._region;
  }

  let query = requestOptions.qs?.query as IDataObject;
  // ! Workaround as we still use the IRequestOptions interface which uses uri instead of url
  // ! To change when we replace the interface with IHttpRequestOptions
  const requestWithUri = requestOptions as unknown as IRequestOptions;
  if (requestWithUri.uri) {
    requestOptions.url = requestWithUri.uri;
    endpoint = new URL(requestOptions.url);
    if (service === 'sts') {
      try {
        if (requestWithUri.qs?.Action !== 'GetCallerIdentity') {
          query = requestWithUri.qs as IDataObject;
        } else {
          endpoint.searchParams.set('Action', 'GetCallerIdentity');
          endpoint.searchParams.set('Version', '2011-06-15');
        }
      } catch (err) {
        console.error(err);
      }
    }
    const parsed = parseAwsUrl(endpoint);
    service = parsed.service;
    if (parsed.region) {
      region = parsed.region;
    }
  } else {
    if (!requestOptions.baseURL && !requestOptions.url) {
      let endpointString: string;
      if (service === 'lambda' && credentials.lambdaEndpoint) {
        endpointString = credentials.lambdaEndpoint;
      } else if (service === 'sns' && credentials.snsEndpoint) {
        endpointString = credentials.snsEndpoint;
      } else if (service === 'sqs' && credentials.sqsEndpoint) {
        endpointString = credentials.sqsEndpoint;
      } else if (service === 's3' && credentials.s3Endpoint) {
        endpointString = credentials.s3Endpoint;
      } else if (service === 'ses' && credentials.sesEndpoint) {
        endpointString = credentials.sesEndpoint;
      } else if (service === 'rekognition' && credentials.rekognitionEndpoint) {
        endpointString = credentials.rekognitionEndpoint;
      } else if (service === 'ssm' && credentials.ssmEndpoint) {
        endpointString = credentials.ssmEndpoint;
      } else if (service) {
        const domain = getAwsDomain(region);
        endpointString = `https://${service}.${region}.${domain}`;
      }
      endpoint = new URL(endpointString!.replace('{region}', region) + path);
    } else {
      // If no endpoint is set, we try to decompose the path and use the default endpoint
      const customUrl = new URL(
        `${requestOptions.baseURL!}${requestOptions.url}${path}`,
      );
      const parsed = parseAwsUrl(customUrl);
      service = parsed.service;
      if (parsed.region) {
        region = parsed.region;
      }
      if (service === 'sts') {
        try {
          if (requestWithUri.qs?.Action !== 'GetCallerIdentity') {
            query = requestWithUri.qs as IDataObject;
          } else {
            customUrl.searchParams.set('Action', 'GetCallerIdentity');
            customUrl.searchParams.set('Version', '2011-06-15');
          }
        } catch (err) {
          console.error(err);
        }
      }
      endpoint = customUrl;
    }
  }

  if (query && Object.keys(query).length !== 0) {
    Object.keys(query).forEach((key) => {
      endpoint.searchParams.append(key, query[key] as string);
    });
  }

  if (body && typeof body === 'object' && isObjectEmpty(body)) {
    body = '';
  }

  path = endpoint.pathname + endpoint.search;

  // ! aws4.sign *must* have the body to sign, but we might have .form instead of .body
  const requestWithForm = requestOptions as unknown as {
    form?: Record<string, string>;
  };
  let bodyContent = body !== '' ? body : undefined;
  let contentTypeHeader: string | undefined = undefined;
  if (requestWithForm.form) {
    const params = new URLSearchParams();
    for (const key in requestWithForm.form) {
      params.append(key, requestWithForm.form[key]);
    }
    bodyContent = params.toString();
    contentTypeHeader = 'application/x-www-form-urlencoded';
  }
  const signOpts = {
    ...requestOptions,
    headers: {
      ...(requestOptions.headers ?? {}),
      ...(contentTypeHeader && { 'content-type': contentTypeHeader }),
    },
    host: endpoint.host,
    method,
    path,
    body: bodyContent,
    region,
  } as unknown as Request;

  const securityHeaders = {
    accessKeyId: `${credentials.accessKeyId}`.trim(),
    secretAccessKey: `${credentials.secretAccessKey}`.trim(),
    sessionToken: credentials.temporaryCredentials
      ? `${credentials.sessionToken}`.trim()
      : undefined,
  };
  console.log('Security Headers:', securityHeaders);
  try {
    sign(signOpts, securityHeaders);
  } catch (err) {
    console.error(err);
  }
  const options: IHttpRequestOptions = {
    ...requestOptions,
    headers: signOpts.headers,
    method,
    url: endpoint.origin + path,
    body: signOpts.body,
    qs: undefined, // override since it's already in the url
  };
  console.log('Signed Request Options:', options);

  return options;
}
