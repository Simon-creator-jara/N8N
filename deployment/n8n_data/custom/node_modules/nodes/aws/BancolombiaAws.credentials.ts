import type { Request } from 'aws4';
import { sign } from 'aws4';
import { STSClient, AssumeRoleCommand } from '@aws-sdk/client-sts';
import type {
  ICredentialDataDecryptedObject,
  ICredentialType,
  IDataObject,
  IHttpRequestHelper,
  INodeProperties,
  IHttpRequestOptions,
  IRequestOptions,
} from 'n8n-workflow';
import { isObjectEmpty } from 'n8n-workflow';

type RegionData = {
  name: string;
  displayName: string;
  location: string;
  domain?: string;
};

const globalDomain = 'amazonaws.com';

export const regions: RegionData[] = [
  {
    name: 'us-east-1',
    displayName: 'US East',
    location: 'N. Virginia',
  },
] as const;

export type AWSRegion = (typeof regions)[number]['name'];
export type BancolombiaAwsCredentialsType = {
  region: AWSRegion;
  temporaryCredentials: boolean;
  awsCredentials: boolean;
  assumeRole: boolean;
  accessKeyId?: string;
  secretAccessKey?: string;
  sessionToken?: string;
  roleToAssume?: string;
  durationSeconds?: number;
  customEndpoints: boolean;
  rekognitionEndpoint?: string;
  lambdaEndpoint?: string;
  snsEndpoint?: string;
  sesEndpoint?: string;
  sqsEndpoint?: string;
  s3Endpoint?: string;
  ssmEndpoint?: string;
};

function getAwsDomain(region: AWSRegion): string {
  return regions.find((r) => r.name === region)?.domain ?? globalDomain;
}

// Some AWS services are global and don't have a region
// https://docs.aws.amazon.com/general/latest/gr/rande.html#global-endpoints
// Example: iam.amazonaws.com (global), s3.us-east-1.amazonaws.com (regional)
function parseAwsUrl(url: URL): { region: AWSRegion | null; service: string } {
  const hostname = url.hostname;
  // Handle both .amazonaws.com and .amazonaws.com.cn domains
  const [service, region] = hostname
    .replace(/\.amazonaws\.com.*$/, '')
    .split('.');
  return { service, region };
}

export class BancolombiaAws implements ICredentialType {
  name = 'bancolombia_aws';

  displayName = 'Bancolombia AWS';

  documentationUrl = 'aws';

  icon = {
    light: 'file:icons/bancolombia-ia.svg',
    dark: 'file:icons/bancolombia-ia.dark.svg',
  } as const;

  properties: INodeProperties[] = [
    {
      displayName: 'Region',
      name: 'region',
      type: 'options',
      options: regions.map((r) => ({
        name: `${r.displayName} (${r.location}) - ${r.name}`,
        value: r.name,
      })),
      default: 'us-east-1',
    },
    {
      displayName: 'Temporary Security Credentials',
      name: 'temporaryCredentials',
      description: 'Support for temporary credentials from AWS STS',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'AWS Credentials',
      name: 'awsCredentials',
      description: 'Support for AWS Credentials Access Keys',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'Assume Role',
      name: 'assumeRole',
      description: 'Support for Assume other roles from n8n ou role',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'Access Key ID',
      name: 'accessKeyId',
      type: 'string',
      displayOptions: {
        show: {
          awsCredentials: [true],
        },
      },
      default: '',
    },
    {
      displayName: 'Secret Access Key',
      name: 'secretAccessKey',
      type: 'string',
      displayOptions: {
        show: {
          awsCredentials: [true],
        },
      },
      default: '',
      typeOptions: {
        password: true,
      },
    },
    {
      displayName: 'Session Token',
      name: 'sessionToken',
      type: 'string',
      displayOptions: {
        show: {
          temporaryCredentials: [true],
        },
      },
      default: '',
      typeOptions: {
        password: true,
      },
    },
    {
      displayName: 'Role To Assume',
      name: 'roleToAssume',
      type: 'string',
      displayOptions: {
        show: {
          assumeRole: [true],
        },
      },
      default: '',
    },
    {
      displayName: 'Duration Seconds',
      name: 'durationSeconds',
      type: 'number',
      displayOptions: {
        show: {
          assumeRole: [true],
        },
      },
      default: 3600,
    },
    {
      displayName: 'Custom Endpoints',
      name: 'customEndpoints',
      type: 'boolean',
      default: false,
    },
    {
      displayName: 'Rekognition Endpoint',
      name: 'rekognitionEndpoint',
      description:
        'If you use Amazon VPC to host n8n, you can establish a connection between your VPC and Rekognition using a VPC endpoint. Leave blank to use the default endpoint.',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://rekognition.{region}.amazonaws.com',
    },
    {
      displayName: 'Lambda Endpoint',
      name: 'lambdaEndpoint',
      description:
        'If you use Amazon VPC to host n8n, you can establish a connection between your VPC and Lambda using a VPC endpoint. Leave blank to use the default endpoint.',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://lambda.{region}.amazonaws.com',
    },
    {
      displayName: 'SNS Endpoint',
      name: 'snsEndpoint',
      description:
        'If you use Amazon VPC to host n8n, you can establish a connection between your VPC and SNS using a VPC endpoint. Leave blank to use the default endpoint.',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://sns.{region}.amazonaws.com',
    },
    {
      displayName: 'SES Endpoint',
      name: 'sesEndpoint',
      description:
        'If you use Amazon VPC to host n8n, you can establish a connection between your VPC and SES using a VPC endpoint. Leave blank to use the default endpoint.',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://email.{region}.amazonaws.com',
    },
    {
      displayName: 'SQS Endpoint',
      name: 'sqsEndpoint',
      description:
        'If you use Amazon VPC to host n8n, you can establish a connection between your VPC and SQS using a VPC endpoint. Leave blank to use the default endpoint.',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://sqs.{region}.amazonaws.com',
    },
    {
      displayName: 'S3 Endpoint',
      name: 's3Endpoint',
      description:
        'If you use Amazon VPC to host n8n, you can establish a connection between your VPC and S3 using a VPC endpoint. Leave blank to use the default endpoint.',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://s3.{region}.amazonaws.com',
    },
    {
      displayName: 'SSM Endpoint',
      name: 'ssmEndpoint',
      description: 'Endpoint for AWS Systems Manager (SSM)',
      type: 'string',
      displayOptions: {
        show: {
          customEndpoints: [true],
        },
      },
      default: '',
      placeholder: 'https://ssm.{region}.amazonaws.com',
    },
  ];

  async preAuthentication(
    this: IHttpRequestHelper,
    credentials: ICredentialDataDecryptedObject,
  ): Promise<IDataObject> {
    const rawCredentials = credentials as BancolombiaAwsCredentialsType;

    // If you require base keys for STS, validate here
    if (rawCredentials.assumeRole) {
      if (!rawCredentials.roleToAssume) {
        throw new Error('roleToAssume is required when assumeRole is enabled.');
      }

      const sts = new STSClient();

      const out = await sts.send(
        new AssumeRoleCommand({
          RoleArn: rawCredentials.roleToAssume.trim(),
          RoleSessionName: `n8n-${Date.now()}`,
          DurationSeconds: rawCredentials.durationSeconds,
        }),
      );

      if (!out.Credentials)
        throw new Error('AssumeRole returned no credentials');

      let accessKeyId = out.Credentials.AccessKeyId!;
      let secretAccessKey = out.Credentials.SecretAccessKey!;
      let sessionToken = out.Credentials.SessionToken!;

      return {
        accessKeyId,
        secretAccessKey,
        sessionToken
      };
    }

    if (
      rawCredentials.temporaryCredentials &&
      rawCredentials.awsCredentials &&
      rawCredentials.sessionToken &&
      rawCredentials.accessKeyId &&
      rawCredentials.secretAccessKey
    ) {
      return {
        accessKeyId: rawCredentials.accessKeyId?.trim(),
        secretAccessKey: rawCredentials.secretAccessKey?.trim(),
        sessionToken: rawCredentials.sessionToken?.trim(),
      };
    }

    if (rawCredentials.awsCredentials) {
      return {
        accessKeyId: rawCredentials.accessKeyId?.trim(),
        secretAccessKey: rawCredentials.secretAccessKey?.trim(),
        sessionToken: undefined,
      };
    }

    return {};
  }

  async authenticate(
    rawCredentials: ICredentialDataDecryptedObject,
    requestOptions: IHttpRequestOptions,
  ): Promise<IHttpRequestOptions> {
    const credentials = rawCredentials as BancolombiaAwsCredentialsType;
    const { accessKeyId, secretAccessKey, sessionToken } = rawCredentials as any;

    let endpoint: URL;
    let service = requestOptions.qs?.service as string;
    let path = (requestOptions.qs?.path as string) ?? '';
    const method = requestOptions.method;
    let body = requestOptions.body;

    let region = credentials.region;
    if (requestOptions.qs?._region) {
      region = requestOptions.qs._region as AWSRegion;
      delete requestOptions.qs._region;
    }

    let query = requestOptions.qs?.query as IDataObject;
    // ! Workaround as we still use the IRequestOptions interface which uses uri instead of url
    // ! To change when we replace the interface with IHttpRequestOptions
    const requestWithUri = requestOptions as unknown as IRequestOptions;
    if (requestWithUri.uri) {
      requestOptions.url = requestWithUri.uri;
      endpoint = new URL(requestOptions.url);
      if (service === 'sts') {
        try {
          if (requestWithUri.qs?.Action !== 'GetCallerIdentity') {
            query = requestWithUri.qs as IDataObject;
          } else {
            endpoint.searchParams.set('Action', 'GetCallerIdentity');
            endpoint.searchParams.set('Version', '2011-06-15');
          }
        } catch (err) {
          console.error(err);
        }
      }
      const parsed = parseAwsUrl(endpoint);
      service = parsed.service;
      if (parsed.region) {
        region = parsed.region;
      }
    } else {
      if (!requestOptions.baseURL && !requestOptions.url) {
        let endpointString: string;
        if (service === 'lambda' && credentials.lambdaEndpoint) {
          endpointString = credentials.lambdaEndpoint;
        } else if (service === 'sns' && credentials.snsEndpoint) {
          endpointString = credentials.snsEndpoint;
        } else if (service === 'sqs' && credentials.sqsEndpoint) {
          endpointString = credentials.sqsEndpoint;
        } else if (service === 's3' && credentials.s3Endpoint) {
          endpointString = credentials.s3Endpoint;
        } else if (service === 'ses' && credentials.sesEndpoint) {
          endpointString = credentials.sesEndpoint;
        } else if (
          service === 'rekognition' &&
          credentials.rekognitionEndpoint
        ) {
          endpointString = credentials.rekognitionEndpoint;
        } else if (service === 'ssm' && credentials.ssmEndpoint) {
          endpointString = credentials.ssmEndpoint;
        } else if (service) {
          const domain = getAwsDomain(region);
          endpointString = `https://${service}.${region}.${domain}`;
        }
        endpoint = new URL(endpointString!.replace('{region}', region) + path);
      } else {
        // If no endpoint is set, we try to decompose the path and use the default endpoint
        const customUrl = new URL(
          `${requestOptions.baseURL!}${requestOptions.url}${path}`,
        );
        const parsed = parseAwsUrl(customUrl);
        service = parsed.service;
        if (parsed.region) {
          region = parsed.region;
        }
        if (service === 'sts') {
          try {
            customUrl.searchParams.set('Action', 'GetCallerIdentity');
            customUrl.searchParams.set('Version', '2011-06-15');
          } catch (err) {
            console.error(err);
          }
        }
        endpoint = customUrl;
      }
    }

    if (query && Object.keys(query).length !== 0) {
      Object.keys(query).forEach((key) => {
        endpoint.searchParams.append(key, query[key] as string);
      });
    }

    if (body && typeof body === 'object' && isObjectEmpty(body)) {
      body = '';
    }

    path = endpoint.pathname + endpoint.search;

    // ! aws4.sign *must* have the body to sign, but we might have .form instead of .body
    const requestWithForm = requestOptions as unknown as {
      form?: Record<string, string>;
    };
    let bodyContent = body !== '' ? body : undefined;
    let contentTypeHeader: string | undefined = undefined;
    if (requestWithForm.form) {
      const params = new URLSearchParams();
      for (const key in requestWithForm.form) {
        params.append(key, requestWithForm.form[key]);
      }
      bodyContent = params.toString();
      contentTypeHeader = 'application/x-www-form-urlencoded';
    }
    const signOpts = {
      ...requestOptions,
      headers: {
        ...(requestOptions.headers ?? {}),
        ...(contentTypeHeader && { 'content-type': contentTypeHeader }),
      },
      host: endpoint.host,
      method,
      path,
      body: bodyContent,
      region,
    } as unknown as Request;

    const securityHeaders = {
      accessKeyId: accessKeyId,
      secretAccessKey: secretAccessKey,
      sessionToken: sessionToken,
    };
    try {
      sign(signOpts, securityHeaders);
    } catch (err) {
      console.error(err);
    }
    const options: IHttpRequestOptions = {
      ...requestOptions,
      headers: signOpts.headers,
      method,
      url: endpoint.origin + path,
      body: signOpts.body,
      qs: undefined, // override since it's already in the url
    };

    console.log('Signed Request Options:', options);

    return options;
  }
}
