import type {
  ICredentialType,
  INodeProperties,
  IDataObject,
  ICredentialDataDecryptedObject,
  IHttpRequestHelper,
  IHttpRequestOptions,
} from 'n8n-workflow';
import { regions, AwsCredentialsType } from '../nodes/AWS/types';
import { getSTSApiRequestCredentials, getAWSApiRequestOptions } from '../nodes/AWS/utils';


export class BancolombiaPostgres implements ICredentialType {
  name = 'bancolombiaPostgres';

  displayName = 'Bancolombia Postgres';

  icon = {
    light: 'file:../icons/bancolombia-ia.svg',
    dark: 'file:../icons/bancolombia-ia.dark.svg',
  } as const;

  properties: INodeProperties[] = [
    {
      displayName: 'Authentication Method',
      name: 'authenticationMethod',
      type: 'options',
      options: [
        {
          name: 'Set Manual Credentials',
          value: 'manualCredentials',
          description: 'Set Credentials Manually in N8N',
        },
        {
          name: 'Secrets Manager (Recommended)',
          value: 'secretsManager',
          description:
            'Use AWS Secrets Manager to retrieve rds postgress credentials from secrets manager',
        },
      ],
      default: 'secretsManager',
    },
    {
      displayName: 'Secrets Manager Arn/Secret Name',
      name: 'secretsManagerArn',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          authenticationMethod: ['secretsManager'],
        },
      },
      required: true,
    },
    {
      displayName: 'AWS Region',
      name: 'region',
      type: 'options',
      options: regions.map((r) => ({
        name: `${r.displayName} (${r.location}) - ${r.name}`,
        value: r.name,
      })),
      default: 'us-east-1',
      displayOptions: {
        show: {
          authenticationMethod: ['secretsManager'],
        },
      },
      description: 'The AWS region where the secret is stored',
    },
    {
      displayName: 'AWS Authentication Method',
      name: 'awsAuthenticationMethod',
      type: 'options',
      options: [
        {
          name: 'N8N Role',
          value: 'n8nRole',
          description: 'Use the role assigned to the n8n instance',
        },
        {
          name: 'Assume a Role',
          value: 'assumeRole',
          description: 'Assume a specific role using its ARN',
        },
        {
          name: 'Access Keys',
          value: 'accessKeys',
          description: 'Use an Access Key ID and Secret Access Key',
        },
      ],
      displayOptions: {
        show: {
          authenticationMethod: ['secretsManager'],
        },
      },
      default: 'n8nRole',
    },
    {
      displayName: 'Role ARN',
      name: 'roleArn',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          awsAuthenticationMethod: ['assumeRole'],
          authenticationMethod: ['secretsManager'],
        },
      },
      description: 'The ARN of the role to assume',
      required: true,
    },
    {
      displayName: 'Access Key ID',
      name: 'accessKeyId',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          awsAuthenticationMethod: ['accessKeys'],
          authenticationMethod: ['secretsManager'],
        },
      },
      required: true,
    },
    {
      displayName: 'Secret Access Key',
      name: 'secretAccessKey',
      type: 'string',
      typeOptions: {
        password: true,
      },
      displayOptions: {
        show: {
          awsAuthenticationMethod: ['accessKeys'],
          authenticationMethod: ['secretsManager'],
        },
      },
      default: '',
      required: true,
    },
    {
      displayName: 'Session Token',
      name: 'sessionToken',
      type: 'string',
      typeOptions: {
        password: true,
      },
      displayOptions: {
        show: {
          awsAuthenticationMethod: ['accessKeys'],
          authenticationMethod: ['secretsManager'],
        },
      },
      default: '',
      description:
        'The session token to use for temporary credentials, Only required if you are using temporary credentials',
    },
    {
      displayName: 'Host',
      name: 'host',
      type: 'string',
      default: 'localhost',
      required: true,
      displayOptions: {
        show: {
          authenticationMethod: ['manualCredentials'],
        },
      },
    },
    {
      displayName: 'Database',
      name: 'database',
      type: 'string',
      default: 'postgres',
      required: true,
      displayOptions: {
        show: {
          authenticationMethod: ['manualCredentials'],
        },
      },
    },
    {
      displayName: 'User',
      name: 'user',
      type: 'string',
      default: 'postgres',
      required: true,
      displayOptions: {
        show: {
          authenticationMethod: ['manualCredentials'],
        },
      },
    },
    {
      displayName: 'Password',
      name: 'password',
      type: 'string',
      typeOptions: {
        password: true,
      },
      default: '',
      required: true,
      displayOptions: {
        show: {
          authenticationMethod: ['manualCredentials'],
        },
      },
    },
    {
      displayName: 'Maximum Number of Connections',
      name: 'maxConnections',
      type: 'number',
      default: 100,
      description:
        'Make sure this value times the number of workers you have is lower than the maximum number of connections your postgres instance allows.',
    },
    {
      displayName: 'Ignore SSL Issues (Insecure)',
      name: 'allowUnauthorizedCerts',
      type: 'boolean',
      default: false,
      description:
        'Whether to connect even if SSL certificate validation is not possible',
    },
    {
      displayName: 'SSL',
      name: 'ssl',
      type: 'options',
      displayOptions: {
        show: {
          allowUnauthorizedCerts: [false],
        },
      },
      options: [
        {
          name: 'Allow',
          value: 'allow',
        },
        {
          name: 'Disable',
          value: 'disable',
        },
        {
          name: 'Require',
          value: 'require',
        },
      ],
      default: 'disable',
    },
    {
      displayName: 'Port',
      name: 'port',
      type: 'number',
      default: 5432,
      required: true,
      displayOptions: {
        show: {
          authenticationMethod: ['manualCredentials'],
        },
      },
    },
    {
      displayName: 'AWS Secret Keys Values',
      name: 'awsSecretKeysValue',
      description: 'Secrets Retrieved from AWS Secrets Manager',
      type: 'hidden',
      typeOptions: {
        expirable: true,
      },
      default: '',
    },
  ];

  async preAuthentication(
    this: IHttpRequestHelper,
    credentials: ICredentialDataDecryptedObject,
  ): Promise<IDataObject> {
    console.log('CUSTOM N8N CREDENTIALS: PreAuthenticate hook called');
    try {
      const authenticationMethod = credentials.authenticationMethod as string;
      if (authenticationMethod === 'secretsManager') {
        switch (credentials.awsAuthenticationMethod) {
          case 'n8nRole': {
            const awsCredentials = await getSTSApiRequestCredentials.call(this);
            console.log('AWS Credentials from N8N Role:', awsCredentials);
            return { awsSecretKeysValue: awsCredentials };
          }
          case 'assumeRole': {
            const roleArn = (credentials.roleArn as string) ?? '';
            if (!roleArn.trim()) {
              throw new Error(
                'Role ARN is required for Assume Role AWS authentication method',
              );
            }

            const baseCredentials =
              await getSTSApiRequestCredentials.call(this);
            console.log(
              'AWS Credentials from Assume Role N8N:',
              baseCredentials,
            );

            const assumeRoleRequest = (): IHttpRequestOptions => ({
              method: 'POST',
              url: '',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              qs: {
                service: 'sts',
                path: '/',
                query: {
                  Action: 'AssumeRole',
                  Version: '2011-06-15',
                  RoleArn: roleArn,
                  RoleSessionName: `n8n-custom-api-session-${Date.now()}`,
                  DurationSeconds: '3600',
                },
              },
            });

            const assumeRoleSigned = await getAWSApiRequestOptions(
              assumeRoleRequest(),
              { ...credentials, ...baseCredentials } as AwsCredentialsType,
            );
            console.log('Request Options Signed:', assumeRoleSigned);
            const response = await this.helpers.httpRequest(assumeRoleSigned);
            console.log('Response:', response);

            const assumedCredentials =
              response?.AssumeRoleResponse?.AssumeRoleResult?.Credentials;
            if (!assumedCredentials) {
              throw new Error('Unable to assume role with the provided ARN');
            }

            const mergedCredentials: AwsCredentialsType = {
              ...baseCredentials,
              accessKeyId: assumedCredentials.AccessKeyId,
              secretAccessKey: assumedCredentials.SecretAccessKey,
              sessionToken: assumedCredentials.SessionToken,
            };
            console.log('Assumed Credentials:', mergedCredentials);
            return { awsSecretKeysValue: mergedCredentials };
          }
          case 'accessKeys': {
            const accessKeyId = credentials.accessKeyId as string | undefined;
            const secretAccessKey = credentials.secretAccessKey as
              | string
              | undefined;
            if (!accessKeyId || !secretAccessKey) {
              throw new Error(
                'Access Key ID and Secret Access Key are required for Access Keys AWS authentication method',
              );
            }

            const awsCredentials: AwsCredentialsType = {
              accessKeyId,
              secretAccessKey,
              sessionToken:
                (credentials.sessionToken as string | undefined) || undefined,
              temporaryCredentials: true,
              customEndpoints: false,
              expiration: 3600,
              region:
                (credentials.region as AwsCredentialsType['region']) ??
                'us-east-1',
            };
            console.log('AWS Credentials from Access Keys:', awsCredentials);
            return { awsSecretKeysValue: awsCredentials };
          }
          default: {
            console.log(
              'Unsupported AWS authentication method:',
              credentials.awsAuthenticationMethod,
            );
            break;
          }
        }
      }

      return { awsSecretKeysValue: {} };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(
        `There was an error retrieving AWS Secrets Keys: ${message}`,
      );
    }
  }

  async authenticate(
    rawCredentials: ICredentialDataDecryptedObject,
    requestOptions: IHttpRequestOptions,
  ): Promise<IHttpRequestOptions> {
    const secretId = (rawCredentials.secretsManagerArn as string) ?? '';
    if (!secretId.trim()) {
      throw new Error(
        'Secrets Manager Arn/Secret Name is required to retrieve secrets from aws',
      );
    }

    const secretsManagerRequest = (): IHttpRequestOptions => ({
      method: 'POST',
      body: JSON.stringify({ SecretId: secretId }),
      url: '',
      headers: {
        'X-Amz-Target': 'secretsmanager.GetSecretValue',
        'Content-Type': 'application/x-amz-json-1.1',
      },
      qs: {
        service: 'secretsmanager',
        path: '/',
      },
    });

    const requestOptionsSigned = await getAWSApiRequestOptions(
      secretsManagerRequest(),
      {
        ...rawCredentials,
        ...(rawCredentials.awsSecretKeysValue as AwsCredentialsType),
      } as AwsCredentialsType,
    );
    return requestOptionsSigned;
  }
}
