import type {
  ICredentialType,
  INodeProperties,
  IDataObject,
  ICredentialDataDecryptedObject,
  IHttpRequestHelper,
  IHttpRequestOptions,
} from 'n8n-workflow';
import { regions, AwsCredentialsType } from '../nodes/AWS/types';
import { getSTSApiRequestCredentials, getAWSApiRequestOptions } from '../nodes/AWS/utils';

// eslint-disable-next-line n8n-nodes-base/cred-class-name-unsuffixed
export class BancolombiaCognitoAuth implements ICredentialType {
  // eslint-disable-next-line n8n-nodes-base/cred-class-field-name-unsuffixed
  name = 'bancolombiaCognitoAuth';

  displayName = 'Bancolombia Cognito Auth';

  icon = {
    light: 'file:../icons/bancolombia-ia.svg',
    dark: 'file:../icons/bancolombia-ia.dark.svg',
  } as const;

  properties: INodeProperties[] = [
    {
      displayName: 'Cognito Url',
      name: 'cognitoUrl',
      type: 'string',
      default: '',
      required: true,
    },
    {
      displayName: 'Grant Type',
      name: 'grantType',
      type: 'options',
      options: [
        { name: 'Client Credentials', value: 'client_credentials' }
      ],
      default: '',
      required: true,
    },
    {
      displayName: 'Scopes',
      name: 'scopes',
      type: 'string',
      default: '',
      required: false,
    },
    {
      displayName: 'Authentication Method',
      name: 'authenticationMethod',
      type: 'options',
      options: [
        {
          name: 'Client Id and Client Secret',
          value: 'clientCredentials',
          description: 'Use a Client Id and Client Secret to authenticate',
        },
        {
          name: 'Secrets Manager (Recommended)',
          value: 'secretsManager',
          description: 'Use AWS Secrets Manager to authenticate where the secret contains the Client Id and Client Secret { "clientId": "...", "clientSecret": "..." }',
        }
      ],
      default: 'secretsManager',
    },
    {
      displayName: 'Secrets Manager Arn/Secret Name',
      name: 'secretsManagerArn',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      required: true
    },
    {
      displayName: 'AWS Region',
      name: 'region',
      type: 'options',
      options: regions.map((r) => ({
        name: `${r.displayName} (${r.location}) - ${r.name}`,
        value: r.name,
      })),
      default: 'us-east-1',
      displayOptions: {
        show: {
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      description: 'The AWS region where the secret is stored',
    },
    {
      displayName: 'AWS Authentication Method',
      name: 'awsAuthenticationMethod',
      type: 'options',
      options: [
        {
          name: 'N8N Role',
          value: 'n8nRole',
          description: 'Use the role assigned to the n8n instance',
        },
        {
          name: 'Assume a Role',
          value: 'assumeRole',
          description: 'Assume a specific role using its ARN',
        },
        {
          name: 'Access Keys',
          value: 'accessKeys',
          description: 'Use an Access Key ID and Secret Access Key',
        }
      ],
      displayOptions: {
        show: {
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      default: 'n8nRole',
    },
    {
      displayName: 'Role ARN',
      name: 'roleArn',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          awsAuthenticationMethod: [
            'assumeRole',
          ],
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      description: 'The ARN of the role to assume',
      required: true
    },
    {
      displayName: 'Access Key ID',
      name: 'accessKeyId',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          awsAuthenticationMethod: [
            'accessKeys',
          ],
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      required: true,
    },
    {
      displayName: 'Secret Access Key',
      name: 'secretAccessKey',
      type: 'string',
      typeOptions: {
        password: true,
      },
      displayOptions: {
        show: {
          awsAuthenticationMethod: [
            'accessKeys',
          ],
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      default: '',
      required: true,
    },
    {
      displayName: 'Session Token',
      name: 'sessionToken',
      type: 'string',
      typeOptions: {
        password: true,
      },
      displayOptions: {
        show: {
          awsAuthenticationMethod: [
            'accessKeys',
          ],
          authenticationMethod: [
            'secretsManager',
          ]
        }
      },
      default: '',
      description: 'The session token to use for temporary credentials, Only required if you are using temporary credentials',
    },
    {
      displayName: 'Client ID',
      name: 'clientId',
      type: 'string',
      default: '',
      displayOptions: {
        show: {
          authenticationMethod: [
            'clientCredentials',
          ]
        }
      },
      required: true,
    },
    {
      displayName: 'Client Secret',
      name: 'clientSecret',
      type: 'string',
      typeOptions: {
        password: true,
      },
      displayOptions: {
        show: {
          authenticationMethod: [
            'clientCredentials',
          ]
        }
      },
      default: '',
      required: true
    },
    {
      displayName: 'Secrets Manager Value',
      name: 'secretsManagerValue',
      description: 'Secrets Retrieved from AWS Secrets Manager',
      type: 'hidden',
      typeOptions: {
        expirable: true,
      },
      default: '',
    }
  ];

  async preAuthentication(this: IHttpRequestHelper, credentials: ICredentialDataDecryptedObject): Promise<IDataObject> {
    console.log('CUSTOM N8N CREDENTIALS: PreAuthenticate hook called');
    try {
      const authenticationMethod = credentials.authenticationMethod as string;
      if (authenticationMethod === 'secretsManager') {
        const secretId = (credentials.secretsManagerArn as string) ?? '';
        if (!secretId.trim()) {
          throw new Error('Secrets Manager Arn/Secret Name is required for Secrets Manager authentication method');
        }

        const ensureSecretPayload = (secret: IDataObject): IDataObject => {
          if (secret.clientId === undefined || secret.clientSecret === undefined) {
            throw new Error(
              'Secret retrieved from Secrets Manager must contain clientId and clientSecret fields for example { "clientId": "...", "clientSecret": "..." }',
            );
          }
          return secret;
        };

        const parseSecretResponse = (response: IDataObject): IDataObject => {
          const secretString = response.SecretString as string | undefined;
          if (!secretString) {
            throw new Error('SecretString is empty in the retrieved secret');
          }
          return ensureSecretPayload(JSON.parse(secretString));
        };

        const secretsManagerRequest = (): IHttpRequestOptions => ({
          method: 'POST',
          body: JSON.stringify({ SecretId: secretId }),
          url: '',
          headers: {
            'X-Amz-Target': 'secretsmanager.GetSecretValue',
            'Content-Type': 'application/x-amz-json-1.1',
          },
          qs: {
            service: 'secretsmanager',
            path: '/',
          },
        });

        const fetchSecrets = async (awsCredentials: AwsCredentialsType): Promise<IDataObject> => {
          const requestOptionsSigned = await getAWSApiRequestOptions(
            secretsManagerRequest(),
            { ...credentials, ...awsCredentials } as AwsCredentialsType,
          );
          console.log('Request Options Signed:', requestOptionsSigned);
          const response = await this.helpers.httpRequest(requestOptionsSigned);
          console.log('Response:', response);
          return parseSecretResponse(response);
        };

        switch (credentials.awsAuthenticationMethod) {
          case 'n8nRole': {
            const awsCredentials = await getSTSApiRequestCredentials.call(this);
            console.log('AWS Credentials from N8N Role:', awsCredentials);
            const secrets = await fetchSecrets(awsCredentials);
            return { secretsManagerValue: secrets };
          }
          case 'assumeRole': {
            const roleArn = (credentials.roleArn as string) ?? '';
            if (!roleArn.trim()) {
              throw new Error('Role ARN is required for Assume Role AWS authentication method');
            }

            const baseCredentials = await getSTSApiRequestCredentials.call(this);
            console.log('AWS Credentials from Assume Role N8N:', baseCredentials);

            const assumeRoleRequest = (): IHttpRequestOptions => ({
              method: 'POST',
              url: '',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              qs: {
                service: 'sts',
                path: '/',
                query: {
                  Action: 'AssumeRole',
                  Version: '2011-06-15',
                  RoleArn: roleArn,
                  RoleSessionName: `n8n-custom-api-session-${Date.now()}`,
                  DurationSeconds: '3600',
                },
              },
            });

            const assumeRoleSigned = await getAWSApiRequestOptions(
              assumeRoleRequest(),
              { ...credentials, ...baseCredentials } as AwsCredentialsType,
            );
            console.log('Request Options Signed:', assumeRoleSigned);
            const response = await this.helpers.httpRequest(assumeRoleSigned);
            console.log('Response:', response);

            const assumedCredentials = response?.AssumeRoleResponse?.AssumeRoleResult?.Credentials;
            if (!assumedCredentials) {
              throw new Error('Unable to assume role with the provided ARN');
            }

            const mergedCredentials: AwsCredentialsType = {
              ...baseCredentials,
              accessKeyId: assumedCredentials.AccessKeyId,
              secretAccessKey: assumedCredentials.SecretAccessKey,
              sessionToken: assumedCredentials.SessionToken,
            };
            console.log('Assumed Credentials:', mergedCredentials);
            const secrets = await fetchSecrets(mergedCredentials);
            return { secretsManagerValue: secrets };
          }
          case 'accessKeys': {
            const accessKeyId = credentials.accessKeyId as string | undefined;
            const secretAccessKey = credentials.secretAccessKey as string | undefined;
            if (!accessKeyId || !secretAccessKey) {
              throw new Error('Access Key ID and Secret Access Key are required for Access Keys AWS authentication method');
            }

            const awsCredentials: AwsCredentialsType = {
              accessKeyId,
              secretAccessKey,
              sessionToken: (credentials.sessionToken as string | undefined) || undefined,
              temporaryCredentials: true,
              customEndpoints: false,
              expiration: 3600,
              region: (credentials.region as AwsCredentialsType['region']) ?? 'us-east-1',
            };
            console.log('AWS Credentials from Access Keys:', awsCredentials);
            const secrets = await fetchSecrets(awsCredentials);
            return { secretsManagerValue: secrets };
          }
          default: {
            console.log('Unsupported AWS authentication method:', credentials.awsAuthenticationMethod);
            break;
          }
        }
      }

      if (authenticationMethod === 'clientCredentials') {
        const clientId = credentials.clientId as string | undefined;
        const clientSecret = credentials.clientSecret as string | undefined;
        if (!clientId || !clientSecret) {
          throw new Error('Client ID and Client Secret are required for Client Credentials authentication method');
        }
        return {
          secretsManagerValue: {
            clientId,
            clientSecret,
          } as IDataObject,
        };
      }

      return { secretsManagerValue: {} };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`There was an error retrieving the Cognito bearer token: ${message}`);
    }
  }

  async authenticate(
    rawCredentials: ICredentialDataDecryptedObject,
    requestOptions: IHttpRequestOptions,
  ): Promise<IHttpRequestOptions> {
    console.log('CUSTOM N8N CREDENTIALS: Authenticate hook called');
    console.log('Raw Credentials:', rawCredentials);
    const url = (rawCredentials.cognitoUrl as string) ?? '';
    const trimmedUrl = url.endsWith('/') ? url.slice(0, -1) : url;
    const params = new URLSearchParams();
    params.append('grant_type', String(rawCredentials.grantType ?? ''));
    if (rawCredentials.scopes !== undefined) {
      params.append('scope', String(rawCredentials.scopes ?? ''));
    }

    const secretValues = (rawCredentials.secretsManagerValue as IDataObject) ?? {};
    const clientId = secretValues.clientId as string | undefined;
    const clientSecret = secretValues.clientSecret as string | undefined;

    const requestOptionsCognito: IHttpRequestOptions = {
      method: 'POST',
      url: `${trimmedUrl}/oauth2/token`,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: params.toString(),
      auth: {
        username: clientId as string,
        password: clientSecret as string,
      },
    };
    return requestOptionsCognito;
  }

}
